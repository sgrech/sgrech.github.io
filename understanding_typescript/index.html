<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Understanding Typescript - Env Docs</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Understanding Typescript";
    var mkdocs_page_input_path = "understanding_typescript.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Env Docs</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../cheatsheet/">Cheatsheet</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../vagrant_tutorial/">Vagrant Tutorial</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../vagrant_recipes/">Vagrant Recipes</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../ansible_for_devops/">Ansible For Devops</a>
                    </li>
                </ul>
                <ul class="current">
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">Understanding Typescript</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#getting-started">Getting Started</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#installing-and-using-using-typescript">Installing and using using typescript</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#typesscript-basics-and-basic-types">TypesScript Basics and Basic Types</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#using-types">Using Types</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#working-with-numbers-strings-and-booleans">Working with Numbers, Strings and Booleans</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#type-assignment-type-inference">Type Assignment &amp; Type Inference</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#working-with-tuples">Working with Tuples</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#working-with-enums">Working with Enums</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#working-with-union-types">Working with Union Types</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#working-with-literal-types">Working with Literal Types</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#type-aliases-custom-types">Type Aliases / Custom Types</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#function-return-types-void">Function Return Types &amp; "void"</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#functions-as-types">Functions as Types</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#function-types-callbacks">Function Types &amp; Callbacks</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#the-unknown-type">The "unknown" type</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#the-never-type">The "never" Type</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#the-typescript-compiler-and-its-configuration">The TypeScript Compiler (and its configuration)</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#using-watch-mode">Using "Watch Mode"</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#compiling-the-entire-project-multiple-files">Compiling the Entire Project / Multiple Files</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#understanding-typescript-core-libs">Understanding Typescript Core Libs</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#next-generation-javascript-typescript">Next-Generation JavaScript &amp; TypeScript</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#let-and-const">"let" and "const"</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#arrow-functions">Arrow functions</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#default-function-parameters">Default Function Parameters</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#the-spread-operator">The Spread Operator (...)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#rest-parameters">Rest Parameters</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#array-object-destructuring">Array &amp; Object Destructuring</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#classes-and-interfaces">Classes and Interfaces</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#creating-a-first-class">Creating a First Class</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#constructor-functions-the-this-keyword">Constructor Functions &amp; The "this" Keyword</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#private-and-private-access-modifiers">"private" and "private" Access Modifiers</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#shorthand-initialization">Shorthand Initialization</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#readonly-properties">"readonly" Properties</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#inheritance">Inheritance</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#overriding-properites-the-protected-modifier">Overriding Properites &amp; The "protected" Modifier</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#getters-setters">Getters &amp; Setters</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#static-methods-properties">Static Methods &amp; Properties</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#abstract-classes">Abstract Classes</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#singletons-private-constructors">Singletons &amp; Private Constructors</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#a-first-interface">A First Interface</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#using-interfaces-with-classes">Using Interfaces with Classes</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#readonly-interface-properties">Readonly Interface Properties</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#extending-interfaces">Extending Interfaces</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#interfaces-as-function-types">Interfaces as Function Types</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#optional-parameters-properties">Optional Parameters &amp; Properties</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#advanced-types">Advanced Types</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#intersection-types">Intersection Types</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#more-on-type-guards">More on Type Guards</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#discriminated-unions">Discriminated unions</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#type-casting">Type Casting</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#index-properties">Index Properties</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#function-overloads">Function Overloads</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#optional-chaining">Optional Chaining</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#nullish-coalescing">Nullish Coalescing</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#generics">Generics</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#built-in-generics-what-are-generics">Built-in Generics &amp; What are Generics</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#creating-a-generic-function">Creating a Generic Function</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#working-with-constraints">Working with Constraints</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#another-generic-function">Another Generic Function</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#the-keyof-constraint">The "keyof" Constraint</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#generic-classes">Generic Classes</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#generic-utility-type">Generic Utility Type</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#decorators">Decorators</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#a-first-class-decorator">A First Class Decorator</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#working-with-decorator-factories">Working with Decorator Factories</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#building-more-useful-decorators">Building More Useful Decorators</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#adding-multiple-decorartors">Adding Multiple Decorartors</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#property-accessor-parameter-decorators">Property Accessor &amp; Parameter Decorators</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#returning-and-changing-a-class-in-a-class-decorator">Returning (and changing) a Class in a Class Decorator</a>
    </li>
        </ul>
    </li>
    </ul>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../iptables/">Iptables</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Env Docs</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Understanding Typescript</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="understanding-typescript">Understanding Typescript</h1>
<h2 id="getting-started">Getting Started</h2>
<h3 id="installing-and-using-using-typescript">Installing and using using typescript</h3>
<p>You can install typescript interpreter using npm</p>
<pre><code class="sh">npm install -g typescript
</code></pre>

<p>To use the interpreter you need a typescript file</p>
<pre><code class="typescript">// using-ts.ts
const button = document.querySelector(&quot;button&quot;);
const input1 = document.getElementById(&quot;num1&quot;)! as HTMLInputElement;
const input2 = document.getElementById(&quot;num2&quot;)! as HTMLInputElement;

function add(num1: number, num2: number) {
  return num1 + num2;
}

button.addEventListener(&quot;click&quot;, function() {
  console.log(add(+input1.value, +input2.value));
});
</code></pre>

<p>Run the following command</p>
<pre><code class="sh">tsc using-ts.ts
</code></pre>

<p>And you will get the following output</p>
<pre><code class="javascript">// using-ts.js
var button = document.querySelector(&quot;button&quot;);
var input1 = document.getElementById(&quot;num1&quot;);
var input2 = document.getElementById(&quot;num2&quot;);
function add(num1, num2) {
    return num1 + num2;
}
button.addEventListener(&quot;click&quot;, function () {
    console.log(add(+input1.value, +input2.value));
});
</code></pre>

<h2 id="typesscript-basics-and-basic-types">TypesScript Basics and Basic Types</h2>
<h3 id="using-types">Using Types</h3>
<p>Core Types:</p>
<ul>
<li>number</li>
<li>1, 5.3, -10</li>
<li>string</li>
<li>'Hi', "Hi", `Hi`</li>
<li>boolean</li>
<li>true, false</li>
<li>object:</li>
<li>{age: 30}</li>
<li>Array:</li>
<li>[1, 2, 3]</li>
<li>Tuple:</li>
<li>[1, 2]</li>
<li>Enum:</li>
<li>enum{ NEW, OLD}</li>
</ul>
<p>Example:</p>
<pre><code class="typescript">function add(n1: number, n2: number) {
  return n1 + n2;
}

const number1 = 5;
const number2 = 2.8;

const result = add(number1, number2);
console.log(result);
</code></pre>

<blockquote>
<p>Important: <strong>Type Casing</strong> - The core primitive types in TypeScript are all lowercase!</p>
</blockquote>
<h3 id="working-with-numbers-strings-and-booleans">Working with Numbers, Strings and Booleans</h3>
<p>Example:</p>
<pre><code class="typescript">function add(n1: number, n2: number, showResult: boolean, phrase: string) {
  // if (typeof n1 !== 'number' || typeof n2 !== 'number') {
  //   throw new Error('Incorrect input!');
  // }
  const result = n1 + n2;
  if (showResult) {
    console.log(phrase + result);
  } else {
    return result;
  }
}

const number1 = 5; // 5.0
const number2 = 2.8;
const printResult = true;
const resultPhrase = 'Result is: ';

add(number1, number2, printResult, resultPhrase);
</code></pre>

<h3 id="type-assignment-type-inference">Type Assignment &amp; Type Inference</h3>
<ul>
<li>when a variable has been assigned a value at declaration, you do not need to assign a type as typescript works out the type by inference.</li>
<li>if you declare a variable without assigning a value, you need to declare the variable type</li>
</ul>
<pre><code class="typescript">let number1: number;
number1 = 5;
</code></pre>

<h3 id="working-with-tuples">Working with Tuples</h3>
<pre><code class="typescript">const person: {
  name: string;
  age: number;
  hobbies: string[];
  role: [number, string];
} = {
  name: 'Maximilian',
  age: 30,
  hobbies: ['Sports', 'Cooking'],
  role: [2, 'author']
};
</code></pre>

<h3 id="working-with-enums">Working with Enums</h3>
<pre><code class="typescript">enum Role { ADMIN = 'ADMIN', READ_ONLY = 100, AUTHOR = 'AUTHOR' };

const person = {
  name: 'Maximilian',
  age: 30,
  hobbies: ['Sports', 'Cooking'],
  role: Role.ADMIN
};
</code></pre>

<h3 id="working-with-union-types">Working with Union Types</h3>
<pre><code class="typescript">function combine(input1: number | string, input2: number | string) {
  let result;
  if (typeof input1 === 'number' &amp;&amp; typeof input2 === 'number') {
    result = input1 + input2;
  } else {
    result = input1.toString() + input2.toString();
  }
  return result;
}

const combinedAges = combine(30, 26);
console.log(combinedAges);

const combinedNames = combine('Max', 'Anna');
console.log(combinedNames);
</code></pre>

<h3 id="working-with-literal-types">Working with Literal Types</h3>
<pre><code class="typescript">function combine(
  input1: number | string,
  input2: number | string,
  resultConversion: 'as-number' | 'as-text'
) {
  let result;
  if (typeof input1 === 'number' &amp;&amp; typeof input2 === 'number' || resultConversion === 'as-number') {
    result = +input1 + +input2;
  } else {
    result = input1.toString() + input2.toString();
  }
  return result;
}

const combinedAges = combine(30, 26, 'as-number');
console.log(combinedAges);

const combinedStringAges = combine('30', '26', 'as-number');
console.log(combinedStringAges);

const combinedNames = combine('Max', 'Anna', 'as-text');
console.log(combinedNames);
</code></pre>

<h3 id="type-aliases-custom-types">Type Aliases / Custom Types</h3>
<pre><code class="typescript">type Combinable = number | string;
type ConversionDescriptor = 'as-number' | 'as-text';

function combine(
  input1: Combinable,
  input2: Combinable,
  resultConversion: ConversionDescriptor
) {
  let result;
  if (typeof input1 === 'number' &amp;&amp; typeof input2 === 'number' || resultConversion === 'as-number') {
    result = +input1 + +input2;
  } else {
    result = input1.toString() + input2.toString();
  }
  return result;
}

const combinedAges = combine(30, 26, 'as-number');
console.log(combinedAges);

const combinedStringAges = combine('30', '26', 'as-number');
console.log(combinedStringAges);

const combinedNames = combine('Max', 'Anna', 'as-text');
console.log(combinedNames);
</code></pre>

<p>Type aliases can be used to "create" your own types. You're not limited to storing union types though - you can also provide an alias to a (possibly complex) object type.</p>
<p>For example:</p>
<pre><code class="typescript">type User = { name: string; age: number };
const u1: User = { name: 'Max', age: 30 }; // this works!
</code></pre>

<p>This allows you to avoid unnecessary repetition and manage types centrally.</p>
<p>For example, you can simplify this code:</p>
<pre><code class="typescript">function greet(user: { name: string; age: number }) {
  console.log('Hi, I am ' + user.name);
}

function isOlder(user: { name: string; age: number }, checkAge: number) {
  return checkAge &gt; user.age;
}
</code></pre>

<p>To:</p>
<pre><code class="typescript">type User = { name: string; age: number };

function greet(user: User) {
  console.log('Hi, I am ' + user.name);
}

function isOlder(user: User, checkAge: number) {
  return checkAge &gt; user.age;
}
</code></pre>

<h3 id="function-return-types-void">Function Return Types &amp; "void"</h3>
<pre><code class="typescript">function add(n1: number, n2: number): number {
  return n1 + n2;
}

function printResult(num: number): void {
  console.log('Result: ' + num);
}

function printResult2(num: number): undefined {
  console.log('Result: ' + num);
  return;
}
</code></pre>

<h3 id="functions-as-types">Functions as Types</h3>
<pre><code class="typescript">function add(n1: number, n2: number): number {
  return n1 + n2;
}

let combineValues: Function;
let combineValuesTypes: (a: number, b: number) =&gt; number;

combineValues = add;
combineValuesTypes = add;
</code></pre>

<h3 id="function-types-callbacks">Function Types &amp; Callbacks</h3>
<pre><code class="typescript">function addAndHandle(n1: number, n2: number, cb: (num: number) =&gt; void) {
  const result = n1 + n2;
  cb(result);
}

addAndHandle(10, 20, (result) =&gt; {
  console.log(result)
});
</code></pre>

<h3 id="the-unknown-type">The "unknown" type</h3>
<pre><code class="typescript">let userInput: unknown;
let userName: string;

userInput = 5;
userInput = 'Max';
if (typeof userInput === 'string') {
  userName = userInput;
}
</code></pre>

<h3 id="the-never-type">The "never" Type</h3>
<pre><code class="typescript">function generateError(message: string, code: number): never {
  throw { message: message, errorCode: code };
  // while (true) {}
}

generateError('An error occurred!', 500);

</code></pre>

<h2 id="the-typescript-compiler-and-its-configuration">The TypeScript Compiler (and its configuration)</h2>
<h3 id="using-watch-mode">Using "Watch Mode"</h3>
<pre><code class="sh">tsc app.ts -w
tsc app.ts --watch
</code></pre>

<h3 id="compiling-the-entire-project-multiple-files">Compiling the Entire Project / Multiple Files</h3>
<pre><code class="sh">tsc --init
tsc
tsc --watch
</code></pre>

<h3 id="understanding-typescript-core-libs">Understanding Typescript Core Libs</h3>
<blockquote>
<p><a href="https://www.typescriptlang.org/docs/handbook/tsconfig-json.html">tsconfig docs</a></p>
<p><a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html">compiler options docs</a></p>
</blockquote>
<h2 id="next-generation-javascript-typescript">Next-Generation JavaScript &amp; TypeScript</h2>
<h3 id="let-and-const">"let" and "const"</h3>
<pre><code class="typescript">// const value cannot be changed after assignment
const userName = &quot;Max&quot;;

let age = 30;

age = 29;

function add(a: number, b: number) {
  let result;
  result = a + b;
  return result;
}

if (age &gt; 20) {
  // isOld is available outside of block scope
  var isOld = true;
}

if (age &gt; 30) {
  // isOlder is available only within block scope
  let isOlder = true;
}
</code></pre>

<h3 id="arrow-functions">Arrow functions</h3>
<pre><code class="typescript">const add = (a: number, b: number) =&gt; {
  return a + b;
};

const addAlt = (a: number, b: number) =&gt; a + b;

const printOutput: (a: number | string) =&gt; void = (output) =&gt;
  console.log(output);

const button = document.querySelector(&quot;button&quot;);

if (button) {
  button.addEventListener(&quot;click&quot;, (event) =&gt; console.log(event));
}

printOutput(add(2, 5));
</code></pre>

<h3 id="default-function-parameters">Default Function Parameters</h3>
<pre><code class="typescript">const add = (a: number, b: number = 1) =&gt; a + b;

console.log(add(4));
</code></pre>

<h3 id="the-spread-operator">The Spread Operator (...)</h3>
<pre><code class="typescript">const hobbies = [&quot;Sports&quot;, &quot;Cooking&quot;];

// Method 1
const activeHobbies = [&quot;Hiking&quot;, ...hobbies];

// Method 2
activeHobbies.push(...hobbies);

const person = {
  name: &quot;Max&quot;,
  age: 30,
};

const copiedPerson = { ...person };
</code></pre>

<h3 id="rest-parameters">Rest Parameters</h3>
<pre><code class="typescript">const add = (...numbers: number[]) =&gt; {
  return numbers.reduce((curResult, curValue) =&gt; {
    return curResult + curValue;
  }, 0);
};

const addWithTuples = (...numbers: [number, number, number]) =&gt; {
  return numbers.reduce((curResult, curValue) =&gt; {
    return curResult + curValue;
  }, 0);
};

const addedNumbers = add(5, 10, 2, 3.7);
const addedNumbersTuples = addWithTuples(1, 2, 3)
</code></pre>

<h3 id="array-object-destructuring">Array &amp; Object Destructuring</h3>
<pre><code class="typescript">// Array Destructuring
const hobbies = [&quot;Sports&quot;, &quot;Cooking&quot;, &quot;Hiking&quot;, &quot;Gardening&quot;];

const [hobby1, hobby2, ...remainingHobbies] = hobbies;

// Object Destructuring
const person = {
  firstName: &quot;Max&quot;,
  age: 30,
};

const { firstName: userName, age } = person;
console.log(userName, age);
</code></pre>

<h2 id="classes-and-interfaces">Classes and Interfaces</h2>
<h3 id="creating-a-first-class">Creating a First Class</h3>
<pre><code class="typescript">class Department {
  name: string = &quot;DEFAULT&quot;;

  constructor(n: string) {
    this.name = n;
  }
}

const accounting = new Department(&quot;Accounting&quot;);
console.log(accounting);
</code></pre>

<h3 id="constructor-functions-the-this-keyword">Constructor Functions &amp; The "this" Keyword</h3>
<pre><code class="typescript">class Department {
  name: string = &quot;DEFAULT&quot;;

  constructor(n: string) {
    this.name = n;
  }

  // Optional: add extra type safety
  describe(this: Department) {
    console.log(&quot;Department: &quot; + this.name);
  }
}

const accounting = new Department(&quot;Accounting&quot;);

accounting.describe();

const accountingCopy = { name: &quot;DUMMY&quot;, describe: accounting.describe };
accountingCopy.describe();
// this typically refers to the thing which is responsible for calling the method
</code></pre>

<h3 id="private-and-private-access-modifiers">"private" and "private" Access Modifiers</h3>
<pre><code class="typescript">class Department {
  // NOTE: public modifier is default, no need to write
  public name: string;
  private employees: string[] = [];

  constructor(n: string) {
    this.name = n;
  }

  describe(this: Department) {
    console.log(&quot;Department: &quot; + this.name);
  }

  addEmployee(employee: string) {
    this.employees.push(employee);
  }

  printEmployeeInformation() {
    console.log(this.employees.length);
    console.log(this.employees);
  }
}

const accounting = new Department(&quot;Accounting&quot;);

accounting.addEmployee('Max');
accounting.addEmployee('Manu');

accounting.describe()
accounting.printEmployeeInformation();
</code></pre>

<h3 id="shorthand-initialization">Shorthand Initialization</h3>
<pre><code class="typescript">class Department {
  constructor(private id: string, public name: string) {}

  describe(this: Department) {
    console.log(`Department (${this.id}): ` + this.name);
  }
}

const accounting = new Department(&quot;acn&quot;, &quot;Accounting&quot;);

accounting.describe();
</code></pre>

<h3 id="readonly-properties">"readonly" Properties</h3>
<pre><code class="typescript">class Department {
  // readonly does not allow reassignment of property
  constructor(private readonly id: string, public name: string) {}

  describe(this: Department) {
    console.log(`Department (${this.id}): ` + this.name);
  }
}

const accounting = new Department(&quot;acn&quot;, &quot;Accounting&quot;);

accounting.describe();
</code></pre>

<h3 id="inheritance">Inheritance</h3>
<pre><code class="typescript">class Department {
  private employees: string[] = [];

  constructor(private readonly id: string, public name: string) {}

  describe(this: Department) {
    console.log(`Deparment (${this.id}): ${this.name}`);
  }

  addEmployee(employee: string) {
    this.employees.push(employee);
  }

  printEmployeeInformation() {
    console.log(this.employees.length);
    console.log(this.employees);
  }
}

class ITDeparment extends Department {
  constructor(id: string, public admins: string[]) {
    super(id, &quot;IT&quot;);
  }
}

const it = new ITDeparment(&quot;IT1&quot;, [&quot;John&quot;, &quot;Micheal&quot;]);

it.addEmployee(&quot;Amy&quot;);
it.addEmployee(&quot;Dory&quot;);

it.describe();
it.printEmployeeInformation();

console.log(it);
</code></pre>

<h3 id="overriding-properites-the-protected-modifier">Overriding Properites &amp; The "protected" Modifier</h3>
<pre><code class="typescript">class Department {
  // private properties cannot be inherited,
  // if you want them to be inherited they
  // need to be changed to protected
  protected employees: string[] = [];

  constructor(private readonly id: string, public name: string) {}

  addEmployee(employee: string) {
    this.employees.push(employee);
  }

  describe(this: Department) {
    console.log(`Deparment (${this.id}): ${this.name}`);
  }

  printEmployeeInformation() {
    console.log(this.employees.length);
    console.log(this.employees);
  }
}

class AccountingDepartment extends Department {
  constructor(id: string) {
    super(id, &quot;Accounting&quot;);
  }

  addEmployee(name: string) {
    if (name === &quot;Max&quot;) {
      return;
    }
    this.employees.push(name);
  }
}

const accounting = new AccountingDepartment(&quot;d2&quot;);

accounting.addEmployee(&quot;Max&quot;);
accounting.addEmployee(&quot;Manu&quot;);
accounting.printEmployeeInformation();
</code></pre>

<h3 id="getters-setters">Getters &amp; Setters</h3>
<pre><code class="typescript">class Department {
  protected employees: string[] = [];

  constructor(private readonly id: string, public name: string) {}

  describe(this: Department) {
    console.log(`Department (${this.id}): ${this.name}`);
  }

  addEmployee(employee: string) {
    this.employees.push(employee);
  }

  printEmployeeInformation() {
    console.log(this.employees.length);
    console.log(this.employees);
  }
}

class AccountingDepartment extends Department {
  private lastReport: string;

  get mostRecentReport() {
    if (this.lastReport) {
      return this.lastReport;
    }
    throw new Error(&quot;No report found.&quot;);
  }

  set mostRecentReport(value: string) {
    if (!value) {
      throw new Error(&quot;Please pass in a valid value!&quot;);
    }
    this.addReport(value);
  }

  constructor(id: string, private reports: string[]) {
    super(id, &quot;Accounting&quot;);
    this.lastReport = reports[0];
  }

  addEmployee(name: string) {
    if (name === &quot;Max&quot;) {
      return;
    }
    this.employees.push(name);
  }

  addReport(text: string) {
    this.reports.push(text);
    this.lastReport = text;
  }

  printReports() {
    console.log(this.reports);
  }
}

const accounting = new AccountingDepartment(&quot;d2&quot;, []);

accounting.mostRecentReport = &quot;Year End Report&quot;;
accounting.addReport(&quot;Something went wrong...&quot;);
console.log(accounting.mostRecentReport);

accounting.addEmployee(&quot;Max&quot;);
accounting.addEmployee(&quot;Manu&quot;);

accounting.printReports();
accounting.printEmployeeInformation();
</code></pre>

<h3 id="static-methods-properties">Static Methods &amp; Properties</h3>
<pre><code class="typescript">class Department {
  static fiscalYear = 2020;
  static createEmployee(name: string) {
    return { name: name };
  }
}

const employee1 = Department.createEmployee(&quot;Max&quot;);
console.log(employee1, Department.fiscalYear);
</code></pre>

<h3 id="abstract-classes">Abstract Classes</h3>
<ul>
<li>Abstract methods present in abstract classes force any inherthing class to create an implementation of that method</li>
<li>Abstract classes cannot be initiated</li>
</ul>
<pre><code class="typescript">abstract class Department {
  static fiscalYear = 2020;

  constructor(protected readonly id: string, public name: string) {
  }


  abstract describe(this: Department): void;
}

class ITDepartment extends Department {
  admins: string[];
  constructor(id: string, admins: string[]) {
    super(id, 'IT');
    this.admins = admins;
  }

  describe() {
    console.log('IT Department - ID: ' + this.id);
  }
}

const it = new ITDepartment('d1', ['Max']);

it.describe();
</code></pre>

<h3 id="singletons-private-constructors">Singletons &amp; Private Constructors</h3>
<pre><code class="typescript">class Department {
  private static instance: Department;
  private constructor(protected readonly id: string, public name: string) {
  }

  static getInstance() {
    if (Department.instance) {
      return this.instance;
    }
    this.instance = new Department('d2', 'Accounting');
    return this.instance;
  }

  static createEmployee(name: string) {
    return { name: name };
  }
}

const accounting = Department.getInstance();
const accounting2 = Department.getInstance();

console.log(accounting, accounting2);
</code></pre>

<h3 id="a-first-interface">A First Interface</h3>
<pre><code class="typescript">interface Person {
  name: string;
  age: number;

  greet(phrase: string): void;
}

let user1: Person;

user1 = {
  name: &quot;Max&quot;,
  age: 30,
  greet(phrase: string) {
    console.log(phrase + &quot; &quot; + this.name);
  },
};

user1.greet(&quot;Hi there - I am&quot;);
</code></pre>

<h3 id="using-interfaces-with-classes">Using Interfaces with Classes</h3>
<pre><code class="typescript">interface Greetable {
  name: string;

  greet(phrase: string): void;
}

class Person implements Greetable {
  name: string;
  age = 30;

  constructor(n: string) {
    this.name = n;
  }

  greet(phrase: string) {
    console.log(phrase + &quot; &quot; + this.name);
  }
}

let user1: Greetable;

user1 = new Person(&quot;Max&quot;);

user1.greet(&quot;Hi there - I am&quot;);
console.log(user1);
</code></pre>

<h3 id="readonly-interface-properties">Readonly Interface Properties</h3>
<ul>
<li>readonly properties can only be set once</li>
</ul>
<pre><code class="typescript">interface Greetable {
  readonly name: string;

  greet(phrase: string): void;
}
</code></pre>

<h3 id="extending-interfaces">Extending Interfaces</h3>
<pre><code class="typescript">interface Named {
  readonly name: string;
}

interface Greetable extends Named {
  greet(phrase: string): void;
}

class Person implements Greetable {
  name: string;

  constructor(n: string) {
    this.name = n;
  }

  greet(phrase: string) {
    console.log(phrase + &quot; &quot; + this.name);
  }
}
</code></pre>

<h3 id="interfaces-as-function-types">Interfaces as Function Types</h3>
<pre><code class="typescript">// type AddFn = (a: number, b: number) =&gt; number;
interface AddFn {
  (a: number, b: number): number;
}

let add: AddFn;

add = (n1: number, n2: number) =&gt; {
  return n1 + n2;
};
</code></pre>

<h3 id="optional-parameters-properties">Optional Parameters &amp; Properties</h3>
<pre><code class="typescript">interface Named {
  readonly name?: string;
  outputName?: string;
}

class Person {
  name?: string;

  constructor(n?: string) {
    if (n) {
      this.name = n;
    }
  }

  greet(phrase: string) {
    if (this.name) {
      console.log(phrase + &quot; &quot; + this.name);
    } else {
      console.log(&quot;Hi!&quot;);
    }
  }
}
</code></pre>

<h2 id="advanced-types">Advanced Types</h2>
<h3 id="intersection-types">Intersection Types</h3>
<pre><code class="typescript">type Admin = {
  name: string;
  privileges: string[];
};

type Employee = {
  name: string;
  startDate: Date;
};

// interface ElevatedEmployee extends Employee, Admin {}

type ElevatedEmployee = Admin &amp; Employee;

const e1: ElevatedEmployee = {
  name: &quot;Max&quot;,
  privileges: [&quot;create-server&quot;],
  startDate: new Date(),
};

type Combinable = string | number;
type Numeric = number | boolean;

type Universal = Combinable &amp; Numeric;
</code></pre>

<h3 id="more-on-type-guards">More on Type Guards</h3>
<pre><code class="typescript">type Admin = {
  name: string;
  privileges: string[];
};

type Employee = {
  name: string;
  startDate: Date;
};

// interface ElevatedEmployee extends Employee, Admin {}

type ElevatedEmployee = Admin &amp; Employee;

const e1: ElevatedEmployee = {
  name: &quot;Max&quot;,
  privileges: [&quot;create-server&quot;],
  startDate: new Date(),
};

type Combinable = string | number;
type Numeric = number | boolean;

type Universal = Combinable &amp; Numeric;

function add(a: Combinable, b: Combinable) {
  // Type guard
  if (typeof a === &quot;string&quot; || typeof b === &quot;string&quot;) {
    return a.toString() + b.toString();
  }
  return a + b;
}

type UnknownEmployee = Employee | Admin;

function printEmployeeInformation(emp: UnknownEmployee) {
  console.log(&quot;Name: &quot; + emp.name);
  // Type guard
  if (&quot;privileges&quot; in emp) {
    console.log(&quot;Privileges: &quot; + emp.privileges);
  }
  // Type guard
  if (&quot;startDate&quot; in emp) {
    console.log(&quot;Start Date: &quot; + emp.startDate);
  }
}

printEmployeeInformation({ name: &quot;Manu&quot;, startDate: new Date() });

class Car {
  drive() {
    console.log(&quot;Driving...&quot;);
  }
}

class Truck {
  drive() {
    console.log(&quot;Driving a truck...&quot;);
  }

  loadCargo(amount: number) {
    console.log(&quot;Loading cargo ...&quot; + amount);
  }
}

type Vehicle = Car | Truck;

const v1 = new Car();
const v2 = new Truck();

function useVehicle(vehicle: Vehicle) {
  vehicle.drive();
  // Type Guard
  if (vehicle instanceof Truck) {
    vehicle.loadCargo(1000);
  }
}

useVehicle(v1);
useVehicle(v2);
</code></pre>

<h3 id="discriminated-unions">Discriminated unions</h3>
<pre><code class="typescript">interface Bird {
  type: &quot;bird&quot;;
  flyingSpeed: number;
}

interface Horse {
  type: &quot;horse&quot;;
  runningSpeed: number;
}

type Animal = Bird | Horse;

function moveAnimal(animal: Animal) {
  let speed;
  switch (animal.type) {
    case &quot;bird&quot;:
      speed = animal.flyingSpeed;
      break;
    case &quot;horse&quot;:
      speed = animal.runningSpeed;
  }
  console.log(&quot;Moving at speed: &quot; + speed);
}

moveAnimal({ type: &quot;bird&quot;, flyingSpeed: 10 });
</code></pre>

<h3 id="type-casting">Type Casting</h3>
<pre><code class="typescript">// const userInputElement = &lt;HTMLInputElement&gt;document.getElementById('user-input')!;
const userInputElement = document.getElementById(&quot;user-input&quot;);

if (userInputElement) {
  (userInputElement as HTMLInputElement).value = &quot;Hi there!&quot;;
}
</code></pre>

<h3 id="index-properties">Index Properties</h3>
<pre><code class="typescript">interface ErrorContainer {
  // { email: 'Not a valid email', username: 'Must start with a character!' }
  [prop: string]: string;
}

const errorBag: ErrorContainer = {
  email: &quot;Not a valid email!&quot;,
  username: &quot;Must start with a capital character!&quot;,
};
</code></pre>

<h3 id="function-overloads">Function Overloads</h3>
<pre><code class="typescript">type Combinable = string | number;
type Numeric = number | boolean;

type Universal = Combinable &amp; Numeric;

function add(a: number, b: number): number;
function add(a: string, b: string): string;
function add(a: string, b: number): string;
function add(a: number, b: string): string;
function add(a: Combinable, b: Combinable) {
  if (typeof a === &quot;string&quot; || typeof b === &quot;string&quot;) {
    return a.toString() + b.toString();
  }
  return a + b;
}
</code></pre>

<h3 id="optional-chaining">Optional Chaining</h3>
<pre><code class="typescript">const fetchedUserData = {
  id: &quot;u1&quot;,
  name: &quot;Max&quot;,
  job: {
    title: &quot;CEO&quot;,
    description: &quot;My own company&quot;,
  },
};

console.log(fetchedUserData?.job?.title);
</code></pre>

<h3 id="nullish-coalescing">Nullish Coalescing</h3>
<pre><code class="typescript">const userInput = &quot;&quot;;

// Null Coalescing (??) checks if value is null or undefined,
// but other falsy values are treated as truthy
const storedData = userInput ?? &quot;DEFAULT&quot;;

console.log(storedData);
</code></pre>

<h2 id="generics">Generics</h2>
<h3 id="built-in-generics-what-are-generics">Built-in Generics &amp; What are Generics</h3>
<pre><code class="typescript">const names: Array&lt;string&gt; = []; // string[]

const promise: Promise&lt;number&gt; = new Promise((resolve) =&gt; {
  setTimeout(() =&gt; {
    resolve(10);
  }, 2000);
});

promise.then((data) =&gt; console.log(data.toString()));
</code></pre>

<h3 id="creating-a-generic-function">Creating a Generic Function</h3>
<pre><code class="typescript">function merge&lt;T, U&gt;(objA: T, objB: U) {
  return Object.assign(objA, objB);
}

const mergedObj = merge({ name: &quot;Max&quot;, hobbies: [&quot;Sports&quot;] }, { age: 30 });
console.log(mergedObj.age);
</code></pre>

<h3 id="working-with-constraints">Working with Constraints</h3>
<pre><code class="typescript">function merge&lt;T extends object, U extends object&gt;(objA: T, objB: U) {
  return Object.assign(objA, objB);
}

const mergedObj = merge({ name: 'Max', hobbies: ['Sports'] }, { age: 30 });
console.log(mergedObj);
</code></pre>

<h3 id="another-generic-function">Another Generic Function</h3>
<pre><code class="typescript">interface Lengthy {
  length: number;
}

// Ensure that object passed has 'length' property
function countAndDescribe&lt;T extends Lengthy&gt;(element: T): [T, string] {
  let descriptionText = &quot;Got no value.&quot;;
  if (element.length === 1) {
    descriptionText = &quot;Got 1 element.&quot;;
  } else if (element.length &gt; 1) {
    descriptionText = &quot;Got &quot; + element.length + &quot; elements.&quot;;
  }
  return [element, descriptionText];
}

console.log(countAndDescribe([&quot;Sports&quot;, &quot;Cooking&quot;]));
console.log(countAndDescribe(&quot;Hello there!&quot;));
</code></pre>

<h3 id="the-keyof-constraint">The "keyof" Constraint</h3>
<pre><code class="typescript">// Constraint ensures that U is a key of T
function extractAndConvert&lt;T extends object, U extends keyof T&gt;(
  obj: T,
  key: U
) {
  return 'Value: ' + obj[key];
}

extractAndConvert({ name: 'Max' }, 'name');
</code></pre>

<h3 id="generic-classes">Generic Classes</h3>
<pre><code class="typescript">// constraint to work with primitive types as 
// removeItem will not work with reference values
class DataStorage&lt;T extends string | number | boolean&gt; {
  private data: T[] = [];

  addItem(item: T) {
    this.data.push(item);
  }

  removeItem(item: T) {
    if (this.data.indexOf(item) === -1) {
      return;
    }
    this.data.splice(this.data.indexOf(item), 1); // -1
  }

  getItems() {
    return [...this.data];
  }
}

const textStorage = new DataStorage&lt;string&gt;();
textStorage.addItem('Max');
textStorage.addItem('Manu');
textStorage.removeItem('Max');
console.log(textStorage.getItems());

const numberStorage = new DataStorage&lt;number&gt;();
</code></pre>

<h3 id="generic-utility-type">Generic Utility Type</h3>
<p><a href="https://www.typescriptlang.org/docs/handbook/utility-types.html">Utility Types Docs</a></p>
<pre><code class="typescript">interface CourseGoal {
  title: string;
  description: string;
  completeUntil: Date;
}

function createCourseGoal(
  title: string,
  description: string,
  date: Date
): CourseGoal {
  // Partial sets required properties in an interface optional
  let courseGoal: Partial&lt;CourseGoal&gt; = {};
  courseGoal.title = title;
  courseGoal.description = description;
  courseGoal.completeUntil = date;
  return courseGoal as CourseGoal;
}

// Readonly ensures you cannot change properties
const names: Readonly&lt;string[]&gt; = [&quot;Max&quot;, &quot;Anna&quot;];

// The following won't work
// names.push('Manu');
// names.pop();
</code></pre>

<h2 id="decorators">Decorators</h2>
<h3 id="a-first-class-decorator">A First Class Decorator</h3>
<ul>
<li>Decorators are applied when your class is defined not when it is instantiated</li>
</ul>
<pre><code class="typescript">function Logger(constructor: Function) {
  console.log('Logging...');
  console.log(constructor);
}

@Logger
class Person {
  name = 'Max';

  constructor() {
    console.log('Creating person object...');
  }
}

const pers = new Person();

console.log(pers);
</code></pre>

<h3 id="working-with-decorator-factories">Working with Decorator Factories</h3>
<pre><code class="typescript">function Logger(logString: string) {
  return function (constructor: Function) {
    console.log(logString);
    console.log(constructor);
  };
}

@Logger(&quot;LOGGING - PERSON&quot;)
class Person {
  name = &quot;Max&quot;;

  constructor() {
    console.log(&quot;Creating person object...&quot;);
  }
}

const pers = new Person();

console.log(pers);
</code></pre>

<h3 id="building-more-useful-decorators">Building More Useful Decorators</h3>
<pre><code class="typescript">function WithTemplate(template: string, hookId: string) {
  return function (constructor: any) {
    const hookEl = document.getElementById(hookId);
    const p = new constructor();
    if (hookEl) {
      hookEl.innerHTML = template;
      hookEl.querySelector(&quot;h1&quot;)!.textContent = p.name;
    }
  };
}

@WithTemplate(&quot;&lt;h1&gt;My Person Object&lt;/h1&gt;&quot;, &quot;app&quot;)
class Person {
  name = &quot;Max&quot;;

  constructor() {
    console.log(&quot;Creating person object...&quot;);
  }
}

const pers = new Person();

console.log(pers);
</code></pre>

<h3 id="adding-multiple-decorartors">Adding Multiple Decorartors</h3>
<ul>
<li>with multiple decorators bottom most decorators run first</li>
</ul>
<pre><code class="typescript">function Logger(logString: string) {
  console.log(&quot;LOGGER FACTORY&quot;);
  return function (constructor: Function) {
    console.log(logString);
    console.log(constructor);
  };
}

function WithTemplate(template: string, hookId: string) {
  console.log(&quot;TEMPLATE FACTORY&quot;);
  return function (constructor: any) {
    console.log(&quot;Rendering template&quot;);
    const hookEl = document.getElementById(hookId);
    const p = new constructor();
    if (hookEl) {
      hookEl.innerHTML = template;
      hookEl.querySelector(&quot;h1&quot;)!.textContent = p.name;
    }
  };
}

@Logger(&quot;LOGGING&quot;)
@WithTemplate(&quot;&lt;h1&gt;My Person Object&lt;/h1&gt;&quot;, &quot;app&quot;)
class Person {
  name = &quot;Max&quot;;

  constructor() {
    console.log(&quot;Creating person object...&quot;);
  }
}

const pers = new Person();

console.log(pers);
</code></pre>

<h3 id="property-accessor-parameter-decorators">Property Accessor &amp; Parameter Decorators</h3>
<ul>
<li>Note that decorators run only when a class is defined, not when it is instantiated</li>
</ul>
<pre><code class="typescript">function Log(target: any, propertyName: string | Symbol) {
  console.log(&quot;Property decorator!&quot;);
  console.log(target, propertyName);
}

function Log2(target: any, name: string, descriptor: PropertyDescriptor) {
  console.log(&quot;Accessor decorator!&quot;);
  console.log(target);
  console.log(name);
  console.log(descriptor);
}

function Log3(
  target: any,
  name: string | Symbol,
  descriptor: PropertyDescriptor
) {
  console.log(&quot;Method decorator!&quot;);
  console.log(target);
  console.log(name);
  console.log(descriptor);
}

function Log4(target: any, name: string | Symbol, position: number) {
  console.log(&quot;Parameter decorator!&quot;);
  console.log(target);
  console.log(name);
  console.log(position);
}

class Product {
  @Log
  title: string;
  private _price: number;

  @Log2
  set price(val: number) {
    if (val &gt; 0) {
      this._price = val;
    } else {
      throw new Error(&quot;Invalid price - should be positive!&quot;);
    }
  }

  constructor(t: string, p: number) {
    this.title = t;
    this._price = p;
  }

  @Log3
  getPriceWithTax(@Log4 tax: number) {
    return this._price * (1 + tax);
  }
}
</code></pre>

<h3 id="returning-and-changing-a-class-in-a-class-decorator">Returning (and changing) a Class in a Class Decorator</h3>
<pre><code class="typescript">// This decorator will override the constructor, thus running at object instantiation
function WithTemplate(template: string, hookId: string) {
  console.log(&quot;TEMPLATE FACTORY&quot;);
  return function &lt;T extends { new (...args: any[]): { name: string } }&gt;(
    originalConstructor: T
  ) {
    return class extends originalConstructor {
      constructor(..._: any[]) {
        super();
        console.log(&quot;Rendering template&quot;);
        const hookEl = document.getElementById(hookId);
        if (hookEl) {
          hookEl.innerHTML = template;
          hookEl.querySelector(&quot;h1&quot;)!.textContent = this.name;
        }
      }
    };
  };
}

@WithTemplate(&quot;&lt;h1&gt;My Person Object&lt;/h1&gt;&quot;, &quot;app&quot;)
class Person {
  name = &quot;Max&quot;;

  constructor() {
    console.log(&quot;Creating person object...&quot;);
  }
}
</code></pre>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../iptables/" class="btn btn-neutral float-right" title="Iptables">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../ansible_for_devops/" class="btn btn-neutral" title="Ansible For Devops"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../ansible_for_devops/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../iptables/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
